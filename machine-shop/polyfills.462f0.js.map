{"version":3,"sources":["webpack:///polyfills.462f0.js","webpack:///webpack/bootstrap 9317461f32a67c6e310a","webpack:///../node_modules/promise-polyfill/promise.js","webpack:///../node_modules/unfetch/dist/unfetch.es.js","webpack:///../node_modules/isomorphic-unfetch/browser.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///../node_modules/preact-cli/lib/lib/webpack/polyfills.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","BtxX","root","noop","bind","fn","thisArg","apply","arguments","Promise","this","TypeError","_state","_handled","_value","undefined","_deferreds","doResolve","handle","self","deferred","push","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","promise","ret","e","newValue","then","finale","length","_unhandledRejectionFn","len","Handler","done","value","reason","ex","setTimeoutFunc","setTimeout","prom","constructor","all","arr","res","val","args","remaining","Array","slice","race","values","setImmediate","err","console","warn","_setImmediateFn","_setUnhandledRejectionFn","QAmr","__webpack_exports__","fetch","url","options","response","header","_keys","headers","request","getAllResponseHeaders","replace","key","toLowerCase","ok","status","statusText","responseURL","clone","text","responseText","json","JSON","parse","blob","Blob","keys","entries","has","XMLHttpRequest","open","method","setRequestHeader","withCredentials","credentials","onload","onerror","send","body","VS7n","window","default","h6ac","g","Function","eval","m+Gh","global"],"mappings":"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","file":"polyfills.462f0.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"m+Gh\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"BtxX\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n(function (root) {\n    // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var setTimeoutFunc = setTimeout;\n    function noop() { }\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n        return function () {\n            fn.apply(thisArg, arguments);\n        };\n    }\n    function Promise(fn) {\n        if (!(this instanceof Promise))\n            throw new TypeError('Promises must be constructed via new');\n        if (typeof fn !== 'function')\n            throw new TypeError('not a function');\n        this._state = 0;\n        this._handled = false;\n        this._value = undefined;\n        this._deferreds = [];\n        doResolve(fn, this);\n    }\n    function handle(self, deferred) {\n        while (self._state === 3) {\n            self = self._value;\n        }\n        if (self._state === 0) {\n            self._deferreds.push(deferred);\n            return;\n        }\n        self._handled = true;\n        Promise._immediateFn(function () {\n            var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n            if (cb === null) {\n                (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n                return;\n            }\n            var ret;\n            try {\n                ret = cb(self._value);\n            }\n            catch (e) {\n                reject(deferred.promise, e);\n                return;\n            }\n            resolve(deferred.promise, ret);\n        });\n    }\n    function resolve(self, newValue) {\n        try {\n            // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n            if (newValue === self)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n                var then = newValue.then;\n                if (newValue instanceof Promise) {\n                    self._state = 3;\n                    self._value = newValue;\n                    finale(self);\n                    return;\n                }\n                else if (typeof then === 'function') {\n                    doResolve(bind(then, newValue), self);\n                    return;\n                }\n            }\n            self._state = 1;\n            self._value = newValue;\n            finale(self);\n        }\n        catch (e) {\n            reject(self, e);\n        }\n    }\n    function reject(self, newValue) {\n        self._state = 2;\n        self._value = newValue;\n        finale(self);\n    }\n    function finale(self) {\n        if (self._state === 2 && self._deferreds.length === 0) {\n            Promise._immediateFn(function () {\n                if (!self._handled) {\n                    Promise._unhandledRejectionFn(self._value);\n                }\n            });\n        }\n        for (var i = 0, len = self._deferreds.length; i < len; i++) {\n            handle(self, self._deferreds[i]);\n        }\n        self._deferreds = null;\n    }\n    function Handler(onFulfilled, onRejected, promise) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.promise = promise;\n    }\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n    function doResolve(fn, self) {\n        var done = false;\n        try {\n            fn(function (value) {\n                if (done)\n                    return;\n                done = true;\n                resolve(self, value);\n            }, function (reason) {\n                if (done)\n                    return;\n                done = true;\n                reject(self, reason);\n            });\n        }\n        catch (ex) {\n            if (done)\n                return;\n            done = true;\n            reject(self, ex);\n        }\n    }\n    Promise.prototype['catch'] = function (onRejected) {\n        return this.then(null, onRejected);\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        var prom = new this.constructor(noop);\n        handle(this, new Handler(onFulfilled, onRejected, prom));\n        return prom;\n    };\n    Promise.all = function (arr) {\n        return new Promise(function (resolve, reject) {\n            if (!arr || typeof arr.length === 'undefined')\n                throw new TypeError('Promise.all accepts an array');\n            var args = Array.prototype.slice.call(arr);\n            if (args.length === 0)\n                return resolve([]);\n            var remaining = args.length;\n            function res(i, val) {\n                try {\n                    if (val && (typeof val === 'object' || typeof val === 'function')) {\n                        var then = val.then;\n                        if (typeof then === 'function') {\n                            then.call(val, function (val) {\n                                res(i, val);\n                            }, reject);\n                            return;\n                        }\n                    }\n                    args[i] = val;\n                    if (--remaining === 0) {\n                        resolve(args);\n                    }\n                }\n                catch (ex) {\n                    reject(ex);\n                }\n            }\n            for (var i = 0; i < args.length; i++) {\n                res(i, args[i]);\n            }\n        });\n    };\n    Promise.resolve = function (value) {\n        if (value && typeof value === 'object' && value.constructor === Promise) {\n            return value;\n        }\n        return new Promise(function (resolve) {\n            resolve(value);\n        });\n    };\n    Promise.reject = function (value) {\n        return new Promise(function (resolve, reject) {\n            reject(value);\n        });\n    };\n    Promise.race = function (values) {\n        return new Promise(function (resolve, reject) {\n            for (var i = 0, len = values.length; i < len; i++) {\n                values[i].then(resolve, reject);\n            }\n        });\n    };\n    // Use polyfill for setImmediate for performance gains\n    Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {\n        setImmediate(fn);\n    } || function (fn) {\n        setTimeoutFunc(fn, 0);\n    };\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n        if (typeof console !== 'undefined' && console) {\n            console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n        }\n    };\n    /**\n     * Set the immediate function to execute callbacks\n     * @param fn {function} Function to execute\n     * @deprecated\n     */\n    Promise._setImmediateFn = function _setImmediateFn(fn) {\n        Promise._immediateFn = fn;\n    };\n    /**\n     * Change the function to execute on unhandled rejection\n     * @param {function} fn Function to execute on unhandled rejection\n     * @deprecated\n     */\n    Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n        Promise._unhandledRejectionFn = fn;\n    };\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Promise;\n    }\n    else if (!root.Promise) {\n        root.Promise = Promise;\n    }\n})(this);\n\n\n/***/ }),\n\n/***/ \"QAmr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\nvar index = typeof fetch == 'function' ? fetch.bind() : function (url, options) {\n    options = options || {};\n    return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.open(options.method || 'get', url, true);\n        for (var i in options.headers) {\n            request.setRequestHeader(i, options.headers[i]);\n        }\n        request.withCredentials = options.credentials == 'include';\n        request.onload = function () {\n            resolve(response());\n        };\n        request.onerror = reject;\n        request.send(options.body || null);\n        function response() {\n            var _keys = [], all = [], headers = {}, header;\n            request.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function (m, key, value) {\n                _keys.push(key = key.toLowerCase());\n                all.push([key, value]);\n                header = headers[key];\n                headers[key] = header ? header + \",\" + value : value;\n            });\n            return {\n                ok: (request.status / 100 | 0) == 2,\n                status: request.status,\n                statusText: request.statusText,\n                url: request.responseURL,\n                clone: response,\n                text: function text() {\n                    return Promise.resolve(request.responseText);\n                },\n                json: function json() {\n                    return Promise.resolve(request.responseText).then(JSON.parse);\n                },\n                blob: function blob() {\n                    return Promise.resolve(new Blob([request.response]));\n                },\n                headers: {\n                    keys: function keys() {\n                        return _keys;\n                    },\n                    entries: function entries() {\n                        return all;\n                    },\n                    get: function get(n) {\n                        return headers[n.toLowerCase()];\n                    },\n                    has: function has(n) {\n                        return n.toLowerCase() in headers;\n                    }\n                }\n            };\n        }\n    });\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceMappingURL=unfetch.es.js.map\n\n\n/***/ }),\n\n/***/ \"VS7n\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = window.fetch || (window.fetch = __webpack_require__(\"QAmr\").default || __webpack_require__(\"QAmr\"));\n\n\n/***/ }),\n\n/***/ \"h6ac\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar g;\n// This works in non-strict mode\ng = function () {\n    return this;\n}();\ntry {\n    // This works if eval is allowed (see CSP)\n    g = g || Function(\"return this\")() || (1, eval)(\"this\");\n}\ncatch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\")\n        g = window;\n}\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"m+Gh\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nif (!global.Promise)\n    global.Promise = __webpack_require__(\"BtxX\");\nif (!global.fetch)\n    global.fetch = __webpack_require__(\"VS7n\");\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"h6ac\")))\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// polyfills.462f0.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"m+Gh\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9317461f32a67c6e310a","\"use strict\";\n(function (root) {\n    // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var setTimeoutFunc = setTimeout;\n    function noop() { }\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n        return function () {\n            fn.apply(thisArg, arguments);\n        };\n    }\n    function Promise(fn) {\n        if (!(this instanceof Promise))\n            throw new TypeError('Promises must be constructed via new');\n        if (typeof fn !== 'function')\n            throw new TypeError('not a function');\n        this._state = 0;\n        this._handled = false;\n        this._value = undefined;\n        this._deferreds = [];\n        doResolve(fn, this);\n    }\n    function handle(self, deferred) {\n        while (self._state === 3) {\n            self = self._value;\n        }\n        if (self._state === 0) {\n            self._deferreds.push(deferred);\n            return;\n        }\n        self._handled = true;\n        Promise._immediateFn(function () {\n            var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n            if (cb === null) {\n                (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n                return;\n            }\n            var ret;\n            try {\n                ret = cb(self._value);\n            }\n            catch (e) {\n                reject(deferred.promise, e);\n                return;\n            }\n            resolve(deferred.promise, ret);\n        });\n    }\n    function resolve(self, newValue) {\n        try {\n            // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n            if (newValue === self)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n                var then = newValue.then;\n                if (newValue instanceof Promise) {\n                    self._state = 3;\n                    self._value = newValue;\n                    finale(self);\n                    return;\n                }\n                else if (typeof then === 'function') {\n                    doResolve(bind(then, newValue), self);\n                    return;\n                }\n            }\n            self._state = 1;\n            self._value = newValue;\n            finale(self);\n        }\n        catch (e) {\n            reject(self, e);\n        }\n    }\n    function reject(self, newValue) {\n        self._state = 2;\n        self._value = newValue;\n        finale(self);\n    }\n    function finale(self) {\n        if (self._state === 2 && self._deferreds.length === 0) {\n            Promise._immediateFn(function () {\n                if (!self._handled) {\n                    Promise._unhandledRejectionFn(self._value);\n                }\n            });\n        }\n        for (var i = 0, len = self._deferreds.length; i < len; i++) {\n            handle(self, self._deferreds[i]);\n        }\n        self._deferreds = null;\n    }\n    function Handler(onFulfilled, onRejected, promise) {\n        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n        this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n        this.promise = promise;\n    }\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n    function doResolve(fn, self) {\n        var done = false;\n        try {\n            fn(function (value) {\n                if (done)\n                    return;\n                done = true;\n                resolve(self, value);\n            }, function (reason) {\n                if (done)\n                    return;\n                done = true;\n                reject(self, reason);\n            });\n        }\n        catch (ex) {\n            if (done)\n                return;\n            done = true;\n            reject(self, ex);\n        }\n    }\n    Promise.prototype['catch'] = function (onRejected) {\n        return this.then(null, onRejected);\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        var prom = new this.constructor(noop);\n        handle(this, new Handler(onFulfilled, onRejected, prom));\n        return prom;\n    };\n    Promise.all = function (arr) {\n        return new Promise(function (resolve, reject) {\n            if (!arr || typeof arr.length === 'undefined')\n                throw new TypeError('Promise.all accepts an array');\n            var args = Array.prototype.slice.call(arr);\n            if (args.length === 0)\n                return resolve([]);\n            var remaining = args.length;\n            function res(i, val) {\n                try {\n                    if (val && (typeof val === 'object' || typeof val === 'function')) {\n                        var then = val.then;\n                        if (typeof then === 'function') {\n                            then.call(val, function (val) {\n                                res(i, val);\n                            }, reject);\n                            return;\n                        }\n                    }\n                    args[i] = val;\n                    if (--remaining === 0) {\n                        resolve(args);\n                    }\n                }\n                catch (ex) {\n                    reject(ex);\n                }\n            }\n            for (var i = 0; i < args.length; i++) {\n                res(i, args[i]);\n            }\n        });\n    };\n    Promise.resolve = function (value) {\n        if (value && typeof value === 'object' && value.constructor === Promise) {\n            return value;\n        }\n        return new Promise(function (resolve) {\n            resolve(value);\n        });\n    };\n    Promise.reject = function (value) {\n        return new Promise(function (resolve, reject) {\n            reject(value);\n        });\n    };\n    Promise.race = function (values) {\n        return new Promise(function (resolve, reject) {\n            for (var i = 0, len = values.length; i < len; i++) {\n                values[i].then(resolve, reject);\n            }\n        });\n    };\n    // Use polyfill for setImmediate for performance gains\n    Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {\n        setImmediate(fn);\n    } || function (fn) {\n        setTimeoutFunc(fn, 0);\n    };\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n        if (typeof console !== 'undefined' && console) {\n            console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n        }\n    };\n    /**\n     * Set the immediate function to execute callbacks\n     * @param fn {function} Function to execute\n     * @deprecated\n     */\n    Promise._setImmediateFn = function _setImmediateFn(fn) {\n        Promise._immediateFn = fn;\n    };\n    /**\n     * Change the function to execute on unhandled rejection\n     * @param {function} fn Function to execute on unhandled rejection\n     * @deprecated\n     */\n    Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\n        Promise._unhandledRejectionFn = fn;\n    };\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Promise;\n    }\n    else if (!root.Promise) {\n        root.Promise = Promise;\n    }\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/promise-polyfill/promise.js\n// module id = BtxX\n// module chunks = 0","var index = typeof fetch == 'function' ? fetch.bind() : function (url, options) {\n    options = options || {};\n    return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.open(options.method || 'get', url, true);\n        for (var i in options.headers) {\n            request.setRequestHeader(i, options.headers[i]);\n        }\n        request.withCredentials = options.credentials == 'include';\n        request.onload = function () {\n            resolve(response());\n        };\n        request.onerror = reject;\n        request.send(options.body || null);\n        function response() {\n            var _keys = [], all = [], headers = {}, header;\n            request.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, function (m, key, value) {\n                _keys.push(key = key.toLowerCase());\n                all.push([key, value]);\n                header = headers[key];\n                headers[key] = header ? header + \",\" + value : value;\n            });\n            return {\n                ok: (request.status / 100 | 0) == 2,\n                status: request.status,\n                statusText: request.statusText,\n                url: request.responseURL,\n                clone: response,\n                text: function text() {\n                    return Promise.resolve(request.responseText);\n                },\n                json: function json() {\n                    return Promise.resolve(request.responseText).then(JSON.parse);\n                },\n                blob: function blob() {\n                    return Promise.resolve(new Blob([request.response]));\n                },\n                headers: {\n                    keys: function keys() {\n                        return _keys;\n                    },\n                    entries: function entries() {\n                        return all;\n                    },\n                    get: function get(n) {\n                        return headers[n.toLowerCase()];\n                    },\n                    has: function has(n) {\n                        return n.toLowerCase() in headers;\n                    }\n                }\n            };\n        }\n    });\n};\nexport default index;\n//# sourceMappingURL=unfetch.es.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/unfetch/dist/unfetch.es.js\n// module id = QAmr\n// module chunks = 0","\"use strict\";\nmodule.exports = window.fetch || (window.fetch = require('unfetch').default || require('unfetch'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/isomorphic-unfetch/browser.js\n// module id = VS7n\n// module chunks = 0","\"use strict\";\nvar g;\n// This works in non-strict mode\ng = function () {\n    return this;\n}();\ntry {\n    // This works if eval is allowed (see CSP)\n    g = g || Function(\"return this\")() || (1, eval)(\"this\");\n}\ncatch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\")\n        g = window;\n}\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\nmodule.exports = g;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/webpack/buildin/global.js\n// module id = h6ac\n// module chunks = 0","'use strict';\nif (!global.Promise)\n    global.Promise = require('promise-polyfill');\nif (!global.fetch)\n    global.fetch = require('isomorphic-unfetch');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/preact-cli/lib/lib/webpack/polyfills.js\n// module id = m+Gh\n// module chunks = 0"],"sourceRoot":""}